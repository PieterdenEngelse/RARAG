# Vector configuration for multiple log sources
# Collects logs from AG service, monitoring stack, and system errors
data_dir = "/home/pde/.local/share/vector"

# ============================================================================
# Source: All systemd journal logs (AG + monitoring + system)
# ============================================================================
[sources.systemd_all]
type = "journald"
# Collect from specific units
include_units = [
  "ag.service",
  "loki.service", 
  "otelcol.service", 
  "prometheus.service", 
  "grafana-server.service",
  "alertmanager.service"
]
current_boot_only = false
data_dir = "/home/pde/.local/share/vector"

[transforms.systemd_labels]
type = "remap"
inputs = ["systemd_all"]
source = '''
# Ensure message is string
.message = to_string(.message) ?? ""

# Add systemd fields
.systemd_unit = to_string(.SYSTEMD_UNIT) ?? "unknown"
.hostname = to_string(.host) ?? "localhost"
.priority = to_string(.PRIORITY) ?? "6"
.syslog_identifier = to_string(.SYSLOG_IDENTIFIER) ?? ""

# Extract log level from message
level_result = parse_regex(.message, r'\s+(INFO|WARN|ERROR|DEBUG|TRACE)\s+') ?? null
if level_result != null {
  .level = to_string(level_result[1])
}

# Extract trace_id
trace_result = parse_regex(.message, r'trace_id=([a-f0-9-]+)') ?? null
if trace_result != null {
  .trace_id = to_string(trace_result[1])
}

# Extract HTTP status
status_result = parse_regex(.message, r'status=(\d{3})') ?? null
if status_result != null {
  .http_status = to_string(status_result[1])
}

# Extract HTTP method
method_result = parse_regex(.message, r'method=(GET|POST|PUT|DELETE|PATCH)') ?? null
if method_result != null {
  .http_method = to_string(method_result[1])
}

# Flag errors and warnings
if contains(.message, "ERROR") || contains(.message, "error") {
  .is_error = "true"
}
if contains(.message, "WARN") || contains(.message, "warn") {
  .is_warning = "true"
}
'''

[sinks.loki_systemd]
type = "loki"
inputs = ["systemd_labels"]
endpoint = "http://127.0.0.1:3100"
encoding.codec = "json"
labels.job = "systemd-journal"
labels.systemd_unit = "{{ systemd_unit }}"
labels.hostname = "{{ hostname }}"
labels.priority = "{{ priority }}"
labels.syslog_identifier = "{{ syslog_identifier }}"
labels.trace_id = "{{ trace_id }}"
labels.level = "{{ level }}"
labels.http_status = "{{ http_status }}"
labels.http_method = "{{ http_method }}"
labels.is_error = "{{ is_error }}"
labels.is_warning = "{{ is_warning }}"
healthcheck.enabled = true

# ============================================================================
# Source: System errors (priority 0-3 = emergency, alert, critical, error)
# ============================================================================
[sources.system_errors]
type = "journald"
current_boot_only = false
data_dir = "/home/pde/.local/share/vector"

[transforms.system_errors_filter]
type = "filter"
inputs = ["system_errors"]
condition = '(to_int(.PRIORITY) ?? 6) <= 3'

[transforms.system_errors_labels]
type = "remap"
inputs = ["system_errors_filter"]
source = '''
.message = to_string(.message) ?? ""
.systemd_unit = to_string(.SYSTEMD_UNIT) ?? "unknown"
.hostname = to_string(.host) ?? "localhost"
.priority = to_string(.PRIORITY) ?? "3"
.syslog_identifier = to_string(.SYSLOG_IDENTIFIER) ?? ""
.is_error = "true"
'''

[sinks.loki_system_errors]
type = "loki"
inputs = ["system_errors_labels"]
endpoint = "http://127.0.0.1:3100"
encoding.codec = "json"
labels.job = "system-errors"
labels.systemd_unit = "{{ systemd_unit }}"
labels.hostname = "{{ hostname }}"
labels.priority = "{{ priority }}"
labels.syslog_identifier = "{{ syslog_identifier }}"
labels.is_error = "{{ is_error }}"
healthcheck.enabled = true

# ============================================================================
# Source: Kernel logs (from /var/log/kern.log if available)
# ============================================================================
[sources.kernel_logs]
type = "file"
include = ["/var/log/kern.log"]
read_from = "end"
ignore_not_found = true

[transforms.kernel_labels]
type = "remap"
inputs = ["kernel_logs"]
source = '''
.message = to_string(.message) ?? ""

# Flag errors and warnings
if match(.message, r'(?i)(error|fail|critical|panic|oops|bug|segfault)') {
  .is_error = "true"
}
if match(.message, r'(?i)(warn|warning)') {
  .is_warning = "true"
}
'''

[sinks.loki_kernel]
type = "loki"
inputs = ["kernel_labels"]
endpoint = "http://127.0.0.1:3100"
encoding.codec = "json"
labels.job = "kernel"
labels.host = "localhost"
labels.is_error = "{{ is_error }}"
labels.is_warning = "{{ is_warning }}"
healthcheck.enabled = true

# ============================================================================
# Source: Auth logs (from /var/log/auth.log)
# ============================================================================
[sources.auth_logs]
type = "file"
include = ["/var/log/auth.log"]
read_from = "end"
ignore_not_found = true

[transforms.auth_labels]
type = "remap"
inputs = ["auth_logs"]
source = '''
.message = to_string(.message) ?? ""

# Extract auth events
if match(.message, r'Failed password') {
  .auth_event = "failed_password"
}
if match(.message, r'Accepted password') {
  .auth_event = "accepted_password"
}
if match(.message, r'authentication failure') {
  .auth_event = "auth_failure"
}
if match(.message, r'session opened') {
  .auth_event = "session_opened"
}
if match(.message, r'session closed') {
  .auth_event = "session_closed"
}
if match(.message, r'sudo') {
  .auth_event = "sudo"
}

# Flag failures
if match(.message, r'(?i)(failed|failure|invalid|error|denied)') {
  .is_error = "true"
}
'''

[sinks.loki_auth]
type = "loki"
inputs = ["auth_labels"]
endpoint = "http://127.0.0.1:3100"
encoding.codec = "json"
labels.job = "auth"
labels.host = "localhost"
labels.auth_event = "{{ auth_event }}"
labels.is_error = "{{ is_error }}"
healthcheck.enabled = true

# ============================================================================
# Internal Metrics (monitor Vector itself)
# ============================================================================
[sources.internal_metrics]
type = "internal_metrics"

[sinks.prometheus]
type = "prometheus_exporter"
inputs = ["internal_metrics"]
address = "127.0.0.1:8686"
