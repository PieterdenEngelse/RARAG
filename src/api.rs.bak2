use actix_web::{web, App, HttpResponse, HttpServer, Error};
use actix_multipart::Multipart;
use futures_util::stream::StreamExt;
use std::fs;
use std::io::Write;
use std::path::Path;
use std::sync::{Arc, Mutex, OnceLock};

use crate::retriever::{Retriever, RetrieverError};
use crate::index;

pub const UPLOAD_DIR: &str = "documents";

// Global retriever handle
static RETRIEVER: OnceLock<Arc<Mutex<Retriever>>> = OnceLock::new();

pub fn set_retriever_handle(handle: Arc<Mutex<Retriever>>) {
    let _ = RETRIEVER.set(handle);
}

#[derive(serde::Deserialize)]
pub struct SearchQuery { pub q: String }

#[derive(serde::Deserialize)]
pub struct RerankRequest { pub query_vector: Vec<f32>, pub candidate_indices: Vec<usize> }

#[derive(serde::Deserialize)]
pub struct SummarizeRequest { pub query: String, pub candidates: Vec<String> }

pub async fn health_check() -> Result<HttpResponse, Error> {
    Ok(HttpResponse::Ok().json(serde_json::json!({"status": "healthy"})))
}

pub async fn upload_document(mut payload: Multipart) -> Result<HttpResponse, Error> {
    fs::create_dir_all(UPLOAD_DIR).ok();
    let mut uploaded_files = Vec::new();

    while let Some(item) = payload.next().await {
        let mut field = item?;
        let filename = field
            .content_disposition()
            .as_ref()
            .and_then(|cd| cd.get_filename())
            .ok_or_else(|| actix_web::error::ErrorBadRequest("No filename"))?
            .to_string();

        let ext = Path::new(&filename).extension().and_then(|s| s.to_str()).unwrap_or("");
        if ext != "txt" && ext != "pdf" {
            return Ok(HttpResponse::BadRequest().body("Only .txt/.pdf allowed"));
        }

        let filepath = format!("{}/{}", UPLOAD_DIR, filename);
        let mut f = web::block(move || std::fs::File::create(&filepath)).await??;
        while let Some(chunk) = field.next().await {
            let data = chunk?;
            f = web::block(move || f.write_all(&data).map(|_| f)).await??;
        }

        uploaded_files.push(filename);
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "status": "success",
        "uploaded_files": uploaded_files,
        "message": "Use /reindex to refresh index"
    })))
}

pub async fn list_documents() -> Result<HttpResponse, Error> {
    let mut files = Vec::new();
    if let Ok(entries) = fs::read_dir(UPLOAD_DIR) {
        for entry in entries.flatten() {
            if entry.path().is_file() {
                if let Some(filename) = entry.file_name().to_str() {
                    files.push(filename.to_string());
                }
            }
        }
    }
    Ok(HttpResponse::Ok().json(serde_json::json!({"status":"success","documents":files,"count":files.len()})))
}

pub async fn delete_document(path: web::Path<String>) -> Result<HttpResponse, Error> {
    let filename = path.into_inner();
    let filepath = format!("{}/{}", UPLOAD_DIR, filename);
    match fs::remove_file(&filepath) {
        Ok(_) => Ok(HttpResponse::Ok().json(serde_json::json!({"status":"success","message":format!("Deleted {}", filename)}))),
        Err(_) => Ok(HttpResponse::NotFound().json(serde_json::json!({"status":"error","message":"File not found"})))
    }
}

pub async fn reindex_handler() -> Result<HttpResponse, Error> {
    if let Some(retriever) = RETRIEVER.get() {
        let mut retriever = retriever.lock().unwrap();
        index::index_all_documents(&mut *retriever, UPLOAD_DIR);
        retriever.commit().ok(); // ensure vectors are saved
        Ok(HttpResponse::Ok().json(serde_json::json!({"status":"success","message":"Reindexing complete"})))
    } else {
        Ok(HttpResponse::InternalServerError().json(serde_json::json!({"status":"error","message":"Retriever not initialized"})))
    }
}

pub async fn search_documents(query: web::Query<SearchQuery>) -> Result<HttpResponse, Error> {
    if let Some(retriever) = RETRIEVER.get() {
        let retriever = retriever.lock().unwrap();
        match retriever.search(&query.q) {
            Ok(results) => Ok(HttpResponse::Ok().json(serde_json::json!({"status":"success","results":results}))),
            Err(e) => Ok(HttpResponse::InternalServerError().json(serde_json::json!({"status":"error","message":format!("{}", e)})))
        }
    } else {
        Ok(HttpResponse::InternalServerError().json(serde_json::json!({"status":"error","message":"Retriever not initialized"})))
    }
}

pub async fn rerank(request: web::Json<RerankRequest>) -> Result<HttpResponse, Error> {
    if let Some(retriever) = RETRIEVER.get() {
        let retriever = retriever.lock().unwrap();
        match retriever.rerank_by_vector_similarity(&request.query_vector, &request.candidate_indices) {
            Ok(results) => Ok(HttpResponse::Ok().json(serde_json::json!({"status":"success","results":results}))),
            Err(e) => Ok(HttpResponse::InternalServerError().json(serde_json::json!({"status":"error","message":format!("{}", e)}))),
        }
    } else {
        Ok(HttpResponse::InternalServerError().json(serde_json::json!({"status":"error","message":"Retriever not initialized"})))
    }
}

pub async fn summarize(request: web::Json<SummarizeRequest>) -> Result<HttpResponse, Error> {
    if let Some(retriever) = RETRIEVER.get() {
        let retriever = retriever.lock().unwrap();
        let summary = retriever.summarize_chunks(&request.query, &request.candidates);
        Ok(HttpResponse::Ok().json(serde_json::json!({"status":"success","summary":summary})))
    } else {
        Ok(HttpResponse::InternalServerError().json(serde_json::json!({"status":"error","message":"Retriever not initialized"})))
    }
}

pub async fn save_vectors_handler() -> Result<HttpResponse, Error> {
    if let Some(retriever) = RETRIEVER.get() {
        let retriever = retriever.lock().unwrap();
        match retriever.force_save() {
            Ok(_) => Ok(HttpResponse::Ok().json(serde_json::json!({
                "status": "success",
                "message": "Vectors saved successfully",
                "vector_count": retriever.vectors.len()
            }))),
            Err(e) => Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "status": "error",
                "message": format!("Failed to save vectors: {}", e)
            })))
        }
    } else {
        Ok(HttpResponse::InternalServerError().json(serde_json::json!({
            "status": "error",
            "message": "Retriever not initialized"
        })))
    }
}

pub fn start_api_server() -> impl std::future::Future<Output = std::io::Result<()>> {
    HttpServer::new(|| {
        App::new()
            .route("/health", web::get().to(health_check))
            .route("/upload", web::post().to(upload_document))
            .route("/documents", web::get().to(list_documents))
            .route("/documents/{filename}", web::delete().to(delete_document))
            .route("/reindex", web::post().to(reindex_handler))
            .route("/search", web::get().to(search_documents))
            .route("/rerank", web::post().to(rerank))
            .route("/summarize", web::post().to(summarize))
            .route("/save_vectors", web::post().to(save_vectors_handler))
    })
    .bind("127.0.0.1:8080")
    .unwrap()
    .run()
}
