mod memory;
mod retrieval;
mod rules;
mod api;
mod parser;
mod chunker;

use rules::{Dispatcher, QueryIntent};
use memory::AgentMemory;
use retrieval::Retriever;
use parser::clean_text;
use chunker::chunk_text;
use std::fs;
use std::path::Path;
use std::env;
use notify::{Config, RecommendedWatcher, Watcher, RecursiveMode};
use std::sync::mpsc::channel;
use std::time::Duration;
use ag::embedder::embed;


fn extract_text_from_pdf(path: &Path) -> Option<String> {
    match pdf_extract::extract_text(path) {
        Ok(text) => Some(text),
        Err(e) => {
            eprintln!("Failed to extract text from {:?}: {}", path, e);
            None
        }
    }
}

fn index_all_documents(retriever: &Retriever, docs_path: &str) {
    fs::create_dir_all(docs_path).ok();

    if let Ok(entries) = fs::read_dir(docs_path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() {
                let doc_id = path.file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("unknown");

                let content = if path.extension().and_then(|s| s.to_str()) == Some("pdf") {
                    println!("ğŸ“„ Indexing PDF: {}", doc_id);
                    extract_text_from_pdf(&path)
                } else {
                    println!("ğŸ“„ Indexing text file: {}", doc_id);
                    fs::read_to_string(&path).ok()
                };

                let cleaned = content.map(|text| clean_text(&text));

                if let Some(text) = cleaned {
                    let chunks = chunk_text(&text, 800); // Adjust chunk size as needed
                    for (i, chunk) in chunks.iter().enumerate() {
                        let chunk_id = format!("{}#{}", doc_id, i);
                        retriever.index_doc(&chunk_id, chunk);
                    }
                } else {
                    eprintln!("âš ï¸  Skipping {}: couldn't read content", doc_id);
                }
            }
        }
    }
}

fn start_file_watcher(watch_path: &str, retriever: Retriever) -> notify::Result<()> {
    println!("ğŸ‘ï¸  Watching directory: {}", watch_path);
    println!("ğŸ“ Files added/modified will be automatically indexed");

    let (tx, rx) = channel();
    let config = Config::default().with_poll_interval(Duration::from_secs(2));
    let mut watcher: RecommendedWatcher = Watcher::new(tx, config)?;
    watcher.watch(Path::new(watch_path), RecursiveMode::Recursive)?;

    ctrlc::set_handler(move || {
        println!("\nğŸ‘‹ Received Ctrl+C. Shutting down...");
        std::process::exit(0);
    }).expect("Error setting Ctrl-C handler");

    loop {
        match rx.recv() {
            Ok(event) => match event {
                Ok(ev) => {
                    for path in ev.paths {
                        if path.is_file() {
                            let ext = path.extension().and_then(|s| s.to_str());
                            if ext == Some("txt") || ext == Some("pdf") {
                                println!("ğŸ”„ Change detected: {:?}", path);

                                let doc_id = path.file_name()
                                    .and_then(|n| n.to_str())
                                    .unwrap_or("unknown");

                                let content = if ext == Some("pdf") {
                                    extract_text_from_pdf(&path)
                                } else {
                                    fs::read_to_string(&path).ok()
                                };

                                let cleaned = content.map(|text| clean_text(&text));

                                if let Some(text) = cleaned {
                                    let chunks = chunk_text(&text, 800);
                                    for (i, chunk) in chunks.iter().enumerate() {
                                        let chunk_id = format!("{}#{}", doc_id, i);
                                        retriever.index_doc(&chunk_id, chunk);
                                    }
                                    println!("âœ… Re-indexed: {} ({} chunks)", doc_id, chunks.len());
                                }
                            }
                        }
                    }
                }
                Err(e) => eprintln!("âš ï¸  Watch error: {:?}", e),
            },
            Err(e) => eprintln!("âš ï¸  Channel error: {:?}", e),
        }
    }
}

#[tokio::main]
async fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() > 1 {
        match args[1].as_str() {
            "api" => {
                api::start_api_server().await.expect("Failed to start API server");
            }
            "watch" => {
                let watch_path = args.get(2).map(|s| s.as_str()).unwrap_or("documents");
                let retriever = Retriever::new("tantivy_index");

                println!("ğŸ“š Indexing existing documents...");
                index_all_documents(&retriever, watch_path);
                println!("âœ… Initial indexing complete\n");

                start_file_watcher(watch_path, retriever).expect("Failed to start file watcher");
            }
            "agent" => {
                run_agent_system();
            }
            _ => {
                print_usage();
            }
        }
    } else {
        run_agent_system();
    }
}

fn run_agent_system() {
    let memory = AgentMemory::new("agent.db").expect("Failed to initialize SQLite memory");
    let retriever = Retriever::new("tantivy_index");

    index_all_documents(&retriever, "documents");

    let dispatcher = Dispatcher::new(memory, retriever);
    let agent_id = "agent_001";

    dispatcher.memory.store(agent_id, "Agent initialized with Rust core.", "2025-10-04T15:00:00").unwrap();

    println!("\nğŸ” Testing direct Tantivy search for 'Rust':");
    let direct_results = dispatcher.retriever.search("Rust");
    for r in &direct_results {
        println!("  - {}", r);
    }

    let query = "Rust programming";
    println!("\nğŸ” Hybrid search for '{}':", query);
    let results = dispatcher.handle(QueryIntent::HybridRetrieval, agent_id, query);

    println!("\nğŸ“‹ Final Retrieved Results:");
    for (i, r) in results.iter().enumerate() {
        println!("{}. {}", i + 1, r);
    }
}

fn print_usage() {
    println!("Usage:");
    println!("  cargo run           - Run agent system once");
    println!("  cargo run agent     - Run agent system once");
    println!("  cargo run api       - Start web API server for document uploads");
    println!("  cargo run watch     - Watch documents/ folder and auto-index changes");
    println!("  cargo run watch <path> - Watch custom folder and auto-index changes");
}
